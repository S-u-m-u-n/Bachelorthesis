{"attributes":{"_arrays":{"A":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0","0"],"shape":["M","K"],"storage":"Default","strides":["K","1"],"total_size":"K*M","transient":false},"type":"Array"},"B":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0","0"],"shape":["K","N"],"storage":"Default","strides":["N","1"],"total_size":"K*N","transient":false},"type":"Array"},"__return":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0","0"],"shape":["M","N"],"storage":"Default","strides":["N","1"],"total_size":"M*N","transient":false},"type":"Array"}},"_meta__arrays":{"category":"General","default":{},"desc":"Data descriptors for this SDFG","metatype":"dict"},"_meta_arg_types":{"category":"General","default":[],"desc":"Formal parameter list","metatype":"OrderedDictProperty"},"_meta_constants_prop":{"category":"General","default":{},"desc":"Compile-time constants","metatype":"dict"},"_meta_exit_code":{"category":"General","default":{},"desc":"Code generated in the `__dace_exit` function.","metatype":"dict"},"_meta_global_code":{"category":"General","default":{},"desc":"Code generated in a global scope on the output files.","metatype":"dict"},"_meta_init_code":{"category":"General","default":{},"desc":"Code generated in the `__dace_init` function.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_orig_sdfg":{"category":"General","default":null,"desc":"","metatype":"SDFGReferenceProperty"},"_meta_symbols":{"category":"General","default":{},"desc":"Global symbols for this SDFG","metatype":"dict"},"_meta_transformation_hist":{"category":"General","default":[],"desc":"","metatype":"list"},"arg_types":[],"constants_prop":{},"exit_code":{"frame":{"language":"CPP","string_data":""}},"global_code":{"frame":{"language":"CPP","string_data":""}},"init_code":{"frame":{"language":"CPP","string_data":""}},"instrument":"No_Instrumentation","name":"matmul","orig_sdfg":"{\"attributes\":{\"_arrays\":{\"A\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"M\",\"K\"],\"storage\":\"Default\",\"strides\":[\"K\",\"1\"],\"total_size\":\"K*M\",\"transient\":false},\"type\":\"Array\"},\"B\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"K\",\"N\"],\"storage\":\"Default\",\"strides\":[\"N\",\"1\"],\"total_size\":\"K*N\",\"transient\":false},\"type\":\"Array\"},\"__return\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"M\",\"N\"],\"storage\":\"Default\",\"strides\":[\"N\",\"1\"],\"total_size\":\"M*N\",\"transient\":false},\"type\":\"Array\"}},\"_meta__arrays\":{\"category\":\"General\",\"default\":{},\"desc\":\"Data descriptors for this SDFG\",\"metatype\":\"dict\"},\"_meta_arg_types\":{\"category\":\"General\",\"default\":[],\"desc\":\"Formal parameter list\",\"metatype\":\"OrderedDictProperty\"},\"_meta_constants_prop\":{\"category\":\"General\",\"default\":{},\"desc\":\"Compile-time constants\",\"metatype\":\"dict\"},\"_meta_exit_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_exit` function.\",\"metatype\":\"dict\"},\"_meta_global_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in a global scope on the output files.\",\"metatype\":\"dict\"},\"_meta_init_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_init` function.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_orig_sdfg\":{\"category\":\"General\",\"default\":null,\"desc\":\"\",\"metatype\":\"SDFGReferenceProperty\"},\"_meta_symbols\":{\"category\":\"General\",\"default\":{},\"desc\":\"Global symbols for this SDFG\",\"metatype\":\"dict\"},\"_meta_transformation_hist\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"list\"},\"arg_types\":[],\"constants_prop\":{},\"exit_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"global_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"init_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"instrument\":\"No_Instrumentation\",\"name\":\"matmul\",\"orig_sdfg\":null,\"symbols\":{\"K\":\"int32\",\"M\":\"int32\",\"N\":\"int32\"},\"transformation_hist\":[]},\"edges\":[],\"nodes\":[{\"attributes\":{\"_meta_dynamic_executions\":{\"category\":\"General\",\"default\":true,\"desc\":\"The number of executions of this state is dynamic\",\"metatype\":\"bool\"},\"_meta_executions\":{\"category\":\"General\",\"default\":0,\"desc\":\"The number of times this state gets executed (0 stands for unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"metatype\":\"bool\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_nosync\":{\"category\":\"General\",\"default\":false,\"desc\":\"Do not synchronize at the end of the state\",\"metatype\":\"bool\"},\"_meta_ranges\":{\"category\":\"General\",\"default\":{},\"desc\":\"Variable ranges, typically within loops\",\"metatype\":\"dict\"},\"dynamic_executions\":true,\"executions\":\"0\",\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"location\":{},\"nosync\":false,\"ranges\":{}},\"collapsed\":false,\"edges\":[{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"A\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"K*M\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"K*M\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"3\",\"dst_connector\":\"_a\",\"src\":\"0\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"B\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"K*N\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"K*N\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"3\",\"dst_connector\":\"_b\",\"src\":\"1\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"__return\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"M*N\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"M*N\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":null,\"src\":\"3\",\"src_connector\":\"_c\",\"type\":\"MultiConnectorEdge\"}],\"id\":0,\"label\":\"BinOp_10\",\"nodes\":[{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadOnly\",\"data\":\"A\",\"debuginfo\":{\"end_column\":15,\"end_line\":10,\"filename\":\"/tmp/tmp46zeri8r/fake.py\",\"start_column\":15,\"start_line\":10,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":0,\"label\":\"A\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadOnly\",\"data\":\"B\",\"debuginfo\":{\"end_column\":15,\"end_line\":10,\"filename\":\"/tmp/tmp46zeri8r/fake.py\",\"start_column\":15,\"start_line\":10,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":1,\"label\":\"B\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"WriteOnly\",\"data\":\"__return\",\"debuginfo\":{\"end_column\":15,\"end_line\":10,\"filename\":\"/tmp/tmp46zeri8r/fake.py\",\"start_column\":15,\"start_line\":10,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":2,\"label\":\"__return\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_environments\":{\"category\":\"General\",\"default\":[],\"desc\":\"Environments required by CMake to build and run this code node.\",\"metatype\":\"set\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Name of the CodeNode\",\"metatype\":\"str\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_no_inline\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, this nested SDFG will not be inlined in strict mode (in the InlineSDFG transformation)\",\"metatype\":\"bool\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"SDFG schedule\",\"metatype\":\"ScheduleType\"},\"_meta_sdfg\":{\"category\":\"General\",\"default\":null,\"desc\":\"The SDFG\",\"metatype\":\"SDFGReferenceProperty\"},\"_meta_symbol_mapping\":{\"category\":\"General\",\"default\":{},\"desc\":\"Mapping between internal symbols and their values, expressed as symbolic expressions\",\"metatype\":\"dict\"},\"debuginfo\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"environments\":[],\"in_connectors\":{\"_a\":null,\"_b\":null},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"_MatMult_gemm\",\"location\":{},\"no_inline\":false,\"out_connectors\":{\"_c\":null},\"schedule\":\"Default\",\"sdfg\":\"{\\\"attributes\\\":{\\\"_arrays\\\":{\\\"_a\\\":{\\\"attributes\\\":{\\\"_meta_alignment\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"Allocation alignment in bytes (0 uses compiler-default)\\\",\\\"metatype\\\":\\\"int\\\"},\\\"_meta_allow_conflicts\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dtype\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"int32\\\",\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"typeclass\\\"},\\\"_meta_lifetime\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Scope\\\",\\\"desc\\\":\\\"Data allocation span\\\",\\\"metatype\\\":\\\"AllocationLifetime\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_may_alias\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"This pointer may alias with other pointers in the same function\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_offset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Initial offset to translate all indices by.\\\",\\\"metatype\\\":\\\"list\\\"},\\\"_meta_shape\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_storage\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Default\\\",\\\"desc\\\":\\\"Storage location\\\",\\\"metatype\\\":\\\"StorageType\\\"},\\\"_meta_strides\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_total_size\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":1,\\\"desc\\\":\\\"The total allocated size of the array. Can be used for padding.\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_transient\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"alignment\\\":0,\\\"allow_conflicts\\\":false,\\\"debuginfo\\\":null,\\\"dtype\\\":\\\"float64\\\",\\\"lifetime\\\":\\\"Scope\\\",\\\"location\\\":{},\\\"may_alias\\\":false,\\\"offset\\\":[\\\"0\\\",\\\"0\\\"],\\\"shape\\\":[\\\"M\\\",\\\"K\\\"],\\\"storage\\\":\\\"Default\\\",\\\"strides\\\":[\\\"K\\\",\\\"1\\\"],\\\"total_size\\\":\\\"K*M\\\",\\\"transient\\\":false},\\\"type\\\":\\\"Array\\\"},\\\"_b\\\":{\\\"attributes\\\":{\\\"_meta_alignment\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"Allocation alignment in bytes (0 uses compiler-default)\\\",\\\"metatype\\\":\\\"int\\\"},\\\"_meta_allow_conflicts\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dtype\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"int32\\\",\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"typeclass\\\"},\\\"_meta_lifetime\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Scope\\\",\\\"desc\\\":\\\"Data allocation span\\\",\\\"metatype\\\":\\\"AllocationLifetime\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_may_alias\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"This pointer may alias with other pointers in the same function\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_offset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Initial offset to translate all indices by.\\\",\\\"metatype\\\":\\\"list\\\"},\\\"_meta_shape\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_storage\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Default\\\",\\\"desc\\\":\\\"Storage location\\\",\\\"metatype\\\":\\\"StorageType\\\"},\\\"_meta_strides\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_total_size\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":1,\\\"desc\\\":\\\"The total allocated size of the array. Can be used for padding.\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_transient\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"alignment\\\":0,\\\"allow_conflicts\\\":false,\\\"debuginfo\\\":null,\\\"dtype\\\":\\\"float64\\\",\\\"lifetime\\\":\\\"Scope\\\",\\\"location\\\":{},\\\"may_alias\\\":false,\\\"offset\\\":[\\\"0\\\",\\\"0\\\"],\\\"shape\\\":[\\\"K\\\",\\\"N\\\"],\\\"storage\\\":\\\"Default\\\",\\\"strides\\\":[\\\"N\\\",\\\"1\\\"],\\\"total_size\\\":\\\"K*N\\\",\\\"transient\\\":false},\\\"type\\\":\\\"Array\\\"},\\\"_c\\\":{\\\"attributes\\\":{\\\"_meta_alignment\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"Allocation alignment in bytes (0 uses compiler-default)\\\",\\\"metatype\\\":\\\"int\\\"},\\\"_meta_allow_conflicts\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dtype\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"int32\\\",\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"typeclass\\\"},\\\"_meta_lifetime\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Scope\\\",\\\"desc\\\":\\\"Data allocation span\\\",\\\"metatype\\\":\\\"AllocationLifetime\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_may_alias\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"This pointer may alias with other pointers in the same function\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_offset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Initial offset to translate all indices by.\\\",\\\"metatype\\\":\\\"list\\\"},\\\"_meta_shape\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_storage\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Default\\\",\\\"desc\\\":\\\"Storage location\\\",\\\"metatype\\\":\\\"StorageType\\\"},\\\"_meta_strides\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\\\",\\\"metatype\\\":\\\"tuple\\\"},\\\"_meta_total_size\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":1,\\\"desc\\\":\\\"The total allocated size of the array. Can be used for padding.\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_transient\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"alignment\\\":0,\\\"allow_conflicts\\\":false,\\\"debuginfo\\\":null,\\\"dtype\\\":\\\"float64\\\",\\\"lifetime\\\":\\\"Scope\\\",\\\"location\\\":{},\\\"may_alias\\\":false,\\\"offset\\\":[\\\"0\\\",\\\"0\\\"],\\\"shape\\\":[\\\"M\\\",\\\"N\\\"],\\\"storage\\\":\\\"Default\\\",\\\"strides\\\":[\\\"N\\\",\\\"1\\\"],\\\"total_size\\\":\\\"M*N\\\",\\\"transient\\\":false},\\\"type\\\":\\\"Array\\\"}},\\\"_meta__arrays\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Data descriptors for this SDFG\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_arg_types\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Formal parameter list\\\",\\\"metatype\\\":\\\"OrderedDictProperty\\\"},\\\"_meta_constants_prop\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Compile-time constants\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_exit_code\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Code generated in the `__dace_exit` function.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_global_code\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Code generated in a global scope on the output files.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_init_code\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Code generated in the `__dace_init` function.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_orig_sdfg\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"SDFGReferenceProperty\\\"},\\\"_meta_symbols\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Global symbols for this SDFG\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_transformation_hist\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"list\\\"},\\\"arg_types\\\":[],\\\"constants_prop\\\":{},\\\"exit_code\\\":{\\\"frame\\\":{\\\"language\\\":\\\"CPP\\\",\\\"string_data\\\":\\\"\\\"}},\\\"global_code\\\":{\\\"frame\\\":{\\\"language\\\":\\\"CPP\\\",\\\"string_data\\\":\\\"\\\"}},\\\"init_code\\\":{\\\"frame\\\":{\\\"language\\\":\\\"CPP\\\",\\\"string_data\\\":\\\"\\\"}},\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"name\\\":\\\"_MatMult_gemm_sdfg\\\",\\\"orig_sdfg\\\":null,\\\"symbols\\\":{\\\"K\\\":\\\"int32\\\",\\\"M\\\":\\\"int32\\\",\\\"N\\\":\\\"int32\\\"},\\\"transformation_hist\\\":[]},\\\"edges\\\":[{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_assignments\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Assignments to perform upon transition (e.g., 'x=x+1; y = 0')\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_condition\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"1\\\"},\\\"desc\\\":\\\"Transition condition\\\",\\\"metatype\\\":\\\"CodeBlock\\\"},\\\"assignments\\\":{},\\\"condition\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"1\\\"}},\\\"label\\\":\\\"\\\",\\\"type\\\":\\\"InterstateEdge\\\"}},\\\"dst\\\":\\\"1\\\",\\\"src\\\":\\\"0\\\",\\\"type\\\":\\\"Edge\\\"}],\\\"nodes\\\":[{\\\"attributes\\\":{\\\"_meta_dynamic_executions\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":true,\\\"desc\\\":\\\"The number of executions of this state is dynamic\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_executions\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The number of times this state gets executed (0 stands for unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_is_collapsed\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Show this node/scope/state as collapsed\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_nosync\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Do not synchronize at the end of the state\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_ranges\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Variable ranges, typically within loops\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"dynamic_executions\\\":true,\\\"executions\\\":\\\"0\\\",\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"is_collapsed\\\":false,\\\"location\\\":{},\\\"nosync\\\":false,\\\"ranges\\\":{}},\\\"collapsed\\\":false,\\\"edges\\\":[{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":null,\\\"debuginfo\\\":null,\\\"dst_subset\\\":null,\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"1\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":null,\\\"subset\\\":null,\\\"volume\\\":\\\"1\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"1\\\",\\\"dst_connector\\\":null,\\\"src\\\":\\\"0\\\",\\\"src_connector\\\":null,\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"M*N\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":null,\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"M*N\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"3\\\",\\\"dst_connector\\\":null,\\\"src\\\":\\\"2\\\",\\\"src_connector\\\":\\\"OUT__c\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"_o0\\\",\\\"start\\\":\\\"_o0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"_o1\\\",\\\"start\\\":\\\"_o1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"1\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":null,\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"_o0\\\",\\\"start\\\":\\\"_o0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"_o1\\\",\\\"start\\\":\\\"_o1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"1\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"2\\\",\\\"dst_connector\\\":\\\"IN__c\\\",\\\"src\\\":\\\"1\\\",\\\"src_connector\\\":\\\"out\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"}],\\\"id\\\":0,\\\"label\\\":\\\"_MatMult_gemm_initstate\\\",\\\"nodes\\\":[{\\\"attributes\\\":{\\\"_meta_collapse\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":1,\\\"desc\\\":\\\"How many dimensions to collapse into the parallel range\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"int\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_is_collapsed\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Show this node/scope/state as collapsed\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_label\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"\\\",\\\"desc\\\":\\\"Label of the map\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"str\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_params\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Mapped parameters\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"list\\\"},\\\"_meta_range\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"ranges\\\":[],\\\"type\\\":\\\"Range\\\"},\\\"desc\\\":\\\"Ranges of map parameters\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"Range\\\"},\\\"_meta_schedule\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Default\\\",\\\"desc\\\":\\\"Map schedule\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"ScheduleType\\\"},\\\"_meta_unroll\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Map unrolling\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"bool\\\"},\\\"collapse\\\":1,\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":119,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":119,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{},\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"is_collapsed\\\":false,\\\"label\\\":\\\"gemm_init_map\\\",\\\"out_connectors\\\":{},\\\"params\\\":[\\\"_o0\\\",\\\"_o1\\\"],\\\"range\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"schedule\\\":\\\"Default\\\",\\\"unroll\\\":false},\\\"id\\\":0,\\\"label\\\":\\\"gemm_init_map[_o0=0:M, _o1=0:N]\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"MapEntry\\\"},{\\\"attributes\\\":{\\\"_meta_code\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"\\\"},\\\"desc\\\":\\\"Tasklet code\\\",\\\"metatype\\\":\\\"CodeBlock\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_environments\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Environments required by CMake to build and run this code node.\\\",\\\"metatype\\\":\\\"set\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_label\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"\\\",\\\"desc\\\":\\\"Name of the CodeNode\\\",\\\"metatype\\\":\\\"str\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"code\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"out = 0\\\"},\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":119,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":119,\\\"type\\\":\\\"DebugInfo\\\"},\\\"environments\\\":[],\\\"in_connectors\\\":{},\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"label\\\":\\\"gemm_init\\\",\\\"location\\\":{},\\\"out_connectors\\\":{\\\"out\\\":null}},\\\"id\\\":1,\\\"label\\\":\\\"gemm_init\\\",\\\"scope_entry\\\":\\\"0\\\",\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"Tasklet\\\"},{\\\"attributes\\\":{\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"in_connectors\\\":{\\\"IN__c\\\":null},\\\"out_connectors\\\":{\\\"OUT__c\\\":null}},\\\"id\\\":2,\\\"label\\\":\\\"gemm_init_map[_o0=0:M, _o1=0:N]\\\",\\\"scope_entry\\\":\\\"0\\\",\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"MapExit\\\"},{\\\"attributes\\\":{\\\"_meta_access\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"ReadWrite\\\",\\\"desc\\\":\\\"Type of access to this array\\\",\\\"metatype\\\":\\\"AccessType\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data (array, stream, scalar) to access\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_setzero\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Initialize to zero\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"access\\\":\\\"WriteOnly\\\",\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":1317,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":1317,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{},\\\"out_connectors\\\":{},\\\"setzero\\\":false},\\\"id\\\":3,\\\"label\\\":\\\"_c\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":null,\\\"type\\\":\\\"AccessNode\\\"}],\\\"scope_dict\\\":{\\\"0\\\":[1,2],\\\"-1\\\":[0,3]},\\\"type\\\":\\\"SDFGState\\\"},{\\\"attributes\\\":{\\\"_meta_dynamic_executions\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":true,\\\"desc\\\":\\\"The number of executions of this state is dynamic\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_executions\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The number of times this state gets executed (0 stands for unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_is_collapsed\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Show this node/scope/state as collapsed\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_nosync\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Do not synchronize at the end of the state\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_ranges\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Variable ranges, typically within loops\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"dynamic_executions\\\":true,\\\"executions\\\":\\\"0\\\",\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"is_collapsed\\\":false,\\\"location\\\":{},\\\"nosync\\\":false,\\\"ranges\\\":{}},\\\"collapsed\\\":false,\\\"edges\\\":[{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_a\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":null,\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"K*M*N\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"K - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"K - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"K*M*N\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"0\\\",\\\"dst_connector\\\":\\\"IN__a\\\",\\\"src\\\":\\\"4\\\",\\\"src_connector\\\":null,\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_b\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":null,\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"K*M*N\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"K - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"K - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"K*M*N\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"0\\\",\\\"dst_connector\\\":\\\"IN__b\\\",\\\"src\\\":\\\"3\\\",\\\"src_connector\\\":null,\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_a\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":null,\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"1\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i0\\\",\\\"start\\\":\\\"__i0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i2\\\",\\\"start\\\":\\\"__i2\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i0\\\",\\\"start\\\":\\\"__i0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i2\\\",\\\"start\\\":\\\"__i2\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"1\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"1\\\",\\\"dst_connector\\\":\\\"__a\\\",\\\"src\\\":\\\"0\\\",\\\"src_connector\\\":\\\"OUT__a\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_b\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":null,\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"1\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i2\\\",\\\"start\\\":\\\"__i2\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i1\\\",\\\"start\\\":\\\"__i1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i2\\\",\\\"start\\\":\\\"__i2\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i1\\\",\\\"start\\\":\\\"__i1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"1\\\",\\\"wcr\\\":null,\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"1\\\",\\\"dst_connector\\\":\\\"__b\\\",\\\"src\\\":\\\"0\\\",\\\"src_connector\\\":\\\"OUT__b\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"K*M*N\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":null,\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"K*M*N\\\",\\\"wcr\\\":\\\"(lambda x, y: (x + y))\\\",\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"5\\\",\\\"dst_connector\\\":null,\\\"src\\\":\\\"2\\\",\\\"src_connector\\\":\\\"OUT__c\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"},{\\\"attributes\\\":{\\\"data\\\":{\\\"attributes\\\":{\\\"_meta_allow_oob\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Bypass out-of-bounds validation\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data descriptor attached to this memlet\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"Line information to track source and generated code\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_dynamic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Is the number of elements moved determined at runtime (e.g., data dependent)\\\",\\\"metatype\\\":\\\"Property\\\"},\\\"_meta_other_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_subset\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Subset of elements to move from the data attached to this edge.\\\",\\\"metatype\\\":\\\"SubsetProperty\\\"},\\\"_meta_volume\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":0,\\\"desc\\\":\\\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\\\",\\\"metatype\\\":\\\"SymbolicProperty\\\"},\\\"_meta_wcr\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\\\",\\\"metatype\\\":\\\"LambdaProperty\\\"},\\\"_meta_wcr_nonatomic\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"If True, always generates non-conflicting (non-atomic) writes in resulting code\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"allow_oob\\\":false,\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":null,\\\"dst_subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i0\\\",\\\"start\\\":\\\"__i0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i1\\\",\\\"start\\\":\\\"__i1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"dynamic\\\":false,\\\"num_accesses\\\":\\\"1\\\",\\\"other_subset\\\":null,\\\"src_subset\\\":null,\\\"subset\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"__i0\\\",\\\"start\\\":\\\"__i0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"__i1\\\",\\\"start\\\":\\\"__i1\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"volume\\\":\\\"1\\\",\\\"wcr\\\":\\\"(lambda x, y: (x + y))\\\",\\\"wcr_nonatomic\\\":false},\\\"type\\\":\\\"Memlet\\\"}},\\\"dst\\\":\\\"2\\\",\\\"dst_connector\\\":\\\"IN__c\\\",\\\"src\\\":\\\"1\\\",\\\"src_connector\\\":\\\"__out\\\",\\\"type\\\":\\\"MultiConnectorEdge\\\"}],\\\"id\\\":1,\\\"label\\\":\\\"_MatMult_gemm_state\\\",\\\"nodes\\\":[{\\\"attributes\\\":{\\\"_meta_collapse\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":1,\\\"desc\\\":\\\"How many dimensions to collapse into the parallel range\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"int\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_is_collapsed\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Show this node/scope/state as collapsed\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"bool\\\"},\\\"_meta_label\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"\\\",\\\"desc\\\":\\\"Label of the map\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"str\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_params\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Mapped parameters\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"list\\\"},\\\"_meta_range\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"ranges\\\":[],\\\"type\\\":\\\"Range\\\"},\\\"desc\\\":\\\"Ranges of map parameters\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"Range\\\"},\\\"_meta_schedule\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"Default\\\",\\\"desc\\\":\\\"Map schedule\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"ScheduleType\\\"},\\\"_meta_unroll\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Map unrolling\\\",\\\"indirected\\\":true,\\\"metatype\\\":\\\"bool\\\"},\\\"collapse\\\":1,\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":161,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":161,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{\\\"IN__a\\\":null,\\\"IN__b\\\":null},\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"is_collapsed\\\":false,\\\"label\\\":\\\"gemm_map\\\",\\\"out_connectors\\\":{\\\"OUT__a\\\":null,\\\"OUT__b\\\":null},\\\"params\\\":[\\\"__i0\\\",\\\"__i1\\\",\\\"__i2\\\"],\\\"range\\\":{\\\"ranges\\\":[{\\\"end\\\":\\\"M - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"N - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"},{\\\"end\\\":\\\"K - 1\\\",\\\"start\\\":\\\"0\\\",\\\"step\\\":\\\"1\\\",\\\"tile\\\":\\\"1\\\"}],\\\"type\\\":\\\"Range\\\"},\\\"schedule\\\":\\\"Default\\\",\\\"unroll\\\":false},\\\"id\\\":0,\\\"label\\\":\\\"gemm_map[__i0=0:M, __i1=0:N, __i2=0:K]\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"MapEntry\\\"},{\\\"attributes\\\":{\\\"_meta_code\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"\\\"},\\\"desc\\\":\\\"Tasklet code\\\",\\\"metatype\\\":\\\"CodeBlock\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_environments\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":[],\\\"desc\\\":\\\"Environments required by CMake to build and run this code node.\\\",\\\"metatype\\\":\\\"set\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_instrument\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"No_Instrumentation\\\",\\\"desc\\\":\\\"Measure execution statistics with given method\\\",\\\"metatype\\\":\\\"InstrumentationType\\\"},\\\"_meta_label\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"\\\",\\\"desc\\\":\\\"Name of the CodeNode\\\",\\\"metatype\\\":\\\"str\\\"},\\\"_meta_location\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"Full storage location identifier (e.g., rank, GPU ID)\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"code\\\":{\\\"language\\\":\\\"Python\\\",\\\"string_data\\\":\\\"__out = (__a * __b)\\\"},\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":161,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":161,\\\"type\\\":\\\"DebugInfo\\\"},\\\"environments\\\":[],\\\"in_connectors\\\":{\\\"__a\\\":null,\\\"__b\\\":null},\\\"instrument\\\":\\\"No_Instrumentation\\\",\\\"label\\\":\\\"gemm\\\",\\\"location\\\":{},\\\"out_connectors\\\":{\\\"__out\\\":null}},\\\"id\\\":1,\\\"label\\\":\\\"gemm\\\",\\\"scope_entry\\\":\\\"0\\\",\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"Tasklet\\\"},{\\\"attributes\\\":{\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"in_connectors\\\":{\\\"IN__c\\\":null},\\\"out_connectors\\\":{\\\"OUT__c\\\":null}},\\\"id\\\":2,\\\"label\\\":\\\"gemm_map[__i0=0:M, __i1=0:N, __i2=0:K]\\\",\\\"scope_entry\\\":\\\"0\\\",\\\"scope_exit\\\":\\\"2\\\",\\\"type\\\":\\\"MapExit\\\"},{\\\"attributes\\\":{\\\"_meta_access\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"ReadWrite\\\",\\\"desc\\\":\\\"Type of access to this array\\\",\\\"metatype\\\":\\\"AccessType\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data (array, stream, scalar) to access\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_setzero\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Initialize to zero\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"access\\\":\\\"ReadOnly\\\",\\\"data\\\":\\\"_b\\\",\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":1312,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":1312,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{},\\\"out_connectors\\\":{},\\\"setzero\\\":false},\\\"id\\\":3,\\\"label\\\":\\\"_b\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":null,\\\"type\\\":\\\"AccessNode\\\"},{\\\"attributes\\\":{\\\"_meta_access\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"ReadWrite\\\",\\\"desc\\\":\\\"Type of access to this array\\\",\\\"metatype\\\":\\\"AccessType\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data (array, stream, scalar) to access\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_setzero\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Initialize to zero\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"access\\\":\\\"ReadOnly\\\",\\\"data\\\":\\\"_a\\\",\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":1312,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":1312,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{},\\\"out_connectors\\\":{},\\\"setzero\\\":false},\\\"id\\\":4,\\\"label\\\":\\\"_a\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":null,\\\"type\\\":\\\"AccessNode\\\"},{\\\"attributes\\\":{\\\"_meta_access\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":\\\"ReadWrite\\\",\\\"desc\\\":\\\"Type of access to this array\\\",\\\"metatype\\\":\\\"AccessType\\\"},\\\"_meta_data\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":null,\\\"desc\\\":\\\"Data (array, stream, scalar) to access\\\",\\\"metatype\\\":\\\"DataProperty\\\"},\\\"_meta_debuginfo\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{\\\"end_column\\\":0,\\\"end_line\\\":0,\\\"filename\\\":null,\\\"start_column\\\":0,\\\"start_line\\\":0,\\\"type\\\":\\\"DebugInfo\\\"},\\\"desc\\\":\\\"\\\",\\\"metatype\\\":\\\"DebugInfo\\\"},\\\"_meta_in_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of input connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_out_connectors\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":{},\\\"desc\\\":\\\"A set of output connectors for this node.\\\",\\\"metatype\\\":\\\"dict\\\"},\\\"_meta_setzero\\\":{\\\"category\\\":\\\"General\\\",\\\"default\\\":false,\\\"desc\\\":\\\"Initialize to zero\\\",\\\"metatype\\\":\\\"bool\\\"},\\\"access\\\":\\\"WriteOnly\\\",\\\"data\\\":\\\"_c\\\",\\\"debuginfo\\\":{\\\"end_column\\\":0,\\\"end_line\\\":1317,\\\"filename\\\":\\\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\\\",\\\"start_column\\\":0,\\\"start_line\\\":1317,\\\"type\\\":\\\"DebugInfo\\\"},\\\"in_connectors\\\":{},\\\"out_connectors\\\":{},\\\"setzero\\\":false},\\\"id\\\":5,\\\"label\\\":\\\"_c\\\",\\\"scope_entry\\\":null,\\\"scope_exit\\\":null,\\\"type\\\":\\\"AccessNode\\\"}],\\\"scope_dict\\\":{\\\"0\\\":[1,2],\\\"-1\\\":[0,3,4,5]},\\\"type\\\":\\\"SDFGState\\\"}],\\\"sdfg_list_id\\\":1,\\\"type\\\":\\\"SDFG\\\"}\",\"symbol_mapping\":{\"K\":\"K\",\"M\":\"M\",\"N\":\"N\"}},\"id\":3,\"label\":\"_MatMult_gemm\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"NestedSDFG\"}],\"scope_dict\":{\"-1\":[0,1,2,3]},\"type\":\"SDFGState\"}],\"sdfg_list_id\":0,\"type\":\"SDFG\"}","symbols":{"K":"int32","M":"int32","N":"int32"},"transformation_hist":[{"_meta__subgraph":{"category":"(Debug)","default":{},"desc":"","metatype":"dict"},"_meta_divides_evenly":{"category":"General","default":false,"desc":"Tile size divides dimension length evenly","metatype":"bool"},"_meta_expr_index":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_prefix":{"category":"General","default":"tile","desc":"Prefix for new range symbols","metatype":"str"},"_meta_sdfg_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_state_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_strides":{"category":"General","default":[],"desc":"Tile stride (enables overlapping tiles). If empty, matches tile","metatype":"tuple"},"_meta_tile_offset":{"category":"General","default":null,"desc":"Negative Stride offset per dimension","metatype":"tuple"},"_meta_tile_sizes":{"category":"General","default":["128","128","128"],"desc":"Tile size per dimension","metatype":"tuple"},"_meta_tile_trivial":{"category":"General","default":false,"desc":"Tiles even if tile_size is 1","metatype":"bool"},"_subgraph":{"0":0},"divides_evenly":false,"expr_index":0,"prefix":"tile","sdfg_id":1,"state_id":1,"strides":[],"tile_offset":null,"tile_sizes":["128","128","128"],"tile_trivial":false,"transformation":"MapTiling","type":"Transformation"}]},"edges":[],"nodes":[{"attributes":{"_meta_dynamic_executions":{"category":"General","default":true,"desc":"The number of executions of this state is dynamic","metatype":"bool"},"_meta_executions":{"category":"General","default":0,"desc":"The number of times this state gets executed (0 stands for unbounded)","metatype":"SymbolicProperty"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_is_collapsed":{"category":"General","default":false,"desc":"Show this node/scope/state as collapsed","metatype":"bool"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_nosync":{"category":"General","default":false,"desc":"Do not synchronize at the end of the state","metatype":"bool"},"_meta_ranges":{"category":"General","default":{},"desc":"Variable ranges, typically within loops","metatype":"dict"},"dynamic_executions":true,"executions":"0","instrument":"No_Instrumentation","is_collapsed":false,"location":{},"nosync":false,"ranges":{}},"collapsed":false,"edges":[{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"A","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"K*M","other_subset":null,"src_subset":{"ranges":[{"end":"M - 1","start":"0","step":"1","tile":"1"},{"end":"K - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"M - 1","start":"0","step":"1","tile":"1"},{"end":"K - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"K*M","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"3","dst_connector":"_a","src":"0","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"B","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"K*N","other_subset":null,"src_subset":{"ranges":[{"end":"K - 1","start":"0","step":"1","tile":"1"},{"end":"N - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"K - 1","start":"0","step":"1","tile":"1"},{"end":"N - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"K*N","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"3","dst_connector":"_b","src":"1","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"__return","debuginfo":null,"dst_subset":{"ranges":[{"end":"M - 1","start":"0","step":"1","tile":"1"},{"end":"N - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"M*N","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"M - 1","start":"0","step":"1","tile":"1"},{"end":"N - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"M*N","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"2","dst_connector":null,"src":"3","src_connector":"_c","type":"MultiConnectorEdge"}],"id":0,"label":"BinOp_10","nodes":[{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadOnly","data":"A","debuginfo":{"end_column":15,"end_line":10,"filename":"/tmp/tmp46zeri8r/fake.py","start_column":15,"start_line":10,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":0,"label":"A","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadOnly","data":"B","debuginfo":{"end_column":15,"end_line":10,"filename":"/tmp/tmp46zeri8r/fake.py","start_column":15,"start_line":10,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":1,"label":"B","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"WriteOnly","data":"__return","debuginfo":{"end_column":15,"end_line":10,"filename":"/tmp/tmp46zeri8r/fake.py","start_column":15,"start_line":10,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":2,"label":"__return","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_environments":{"category":"General","default":[],"desc":"Environments required by CMake to build and run this code node.","metatype":"set"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_is_collapsed":{"category":"General","default":false,"desc":"Show this node/scope/state as collapsed","metatype":"bool"},"_meta_label":{"category":"General","default":"","desc":"Name of the CodeNode","metatype":"str"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_no_inline":{"category":"General","default":false,"desc":"If True, this nested SDFG will not be inlined in strict mode (in the InlineSDFG transformation)","metatype":"bool"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_schedule":{"category":"General","default":"Default","desc":"SDFG schedule","metatype":"ScheduleType"},"_meta_sdfg":{"category":"General","default":null,"desc":"The SDFG","metatype":"SDFGReferenceProperty"},"_meta_symbol_mapping":{"category":"General","default":{},"desc":"Mapping between internal symbols and their values, expressed as symbolic expressions","metatype":"dict"},"debuginfo":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"environments":[],"in_connectors":{"_a":null,"_b":null},"instrument":"No_Instrumentation","is_collapsed":false,"label":"_MatMult_gemm","location":{},"no_inline":false,"out_connectors":{"_c":null},"schedule":"Default","sdfg":"{\"attributes\":{\"_arrays\":{\"_a\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"M\",\"K\"],\"storage\":\"Default\",\"strides\":[\"K\",\"1\"],\"total_size\":\"K*M\",\"transient\":false},\"type\":\"Array\"},\"_b\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"K\",\"N\"],\"storage\":\"Default\",\"strides\":[\"N\",\"1\"],\"total_size\":\"K*N\",\"transient\":false},\"type\":\"Array\"},\"_c\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\",\"0\"],\"shape\":[\"M\",\"N\"],\"storage\":\"Default\",\"strides\":[\"N\",\"1\"],\"total_size\":\"M*N\",\"transient\":false},\"type\":\"Array\"}},\"_meta__arrays\":{\"category\":\"General\",\"default\":{},\"desc\":\"Data descriptors for this SDFG\",\"metatype\":\"dict\"},\"_meta_arg_types\":{\"category\":\"General\",\"default\":[],\"desc\":\"Formal parameter list\",\"metatype\":\"OrderedDictProperty\"},\"_meta_constants_prop\":{\"category\":\"General\",\"default\":{},\"desc\":\"Compile-time constants\",\"metatype\":\"dict\"},\"_meta_exit_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_exit` function.\",\"metatype\":\"dict\"},\"_meta_global_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in a global scope on the output files.\",\"metatype\":\"dict\"},\"_meta_init_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_init` function.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_orig_sdfg\":{\"category\":\"General\",\"default\":null,\"desc\":\"\",\"metatype\":\"SDFGReferenceProperty\"},\"_meta_symbols\":{\"category\":\"General\",\"default\":{},\"desc\":\"Global symbols for this SDFG\",\"metatype\":\"dict\"},\"_meta_transformation_hist\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"list\"},\"arg_types\":[],\"constants_prop\":{},\"exit_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"global_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"init_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"instrument\":\"No_Instrumentation\",\"name\":\"_MatMult_gemm_sdfg\",\"orig_sdfg\":null,\"symbols\":{\"K\":\"int32\",\"M\":\"int32\",\"N\":\"int32\"},\"transformation_hist\":[]},\"edges\":[{\"attributes\":{\"data\":{\"attributes\":{\"_meta_assignments\":{\"category\":\"General\",\"default\":{},\"desc\":\"Assignments to perform upon transition (e.g., 'x=x+1; y = 0')\",\"metatype\":\"dict\"},\"_meta_condition\":{\"category\":\"General\",\"default\":{\"language\":\"Python\",\"string_data\":\"1\"},\"desc\":\"Transition condition\",\"metatype\":\"CodeBlock\"},\"assignments\":{},\"condition\":{\"language\":\"Python\",\"string_data\":\"1\"}},\"label\":\"\",\"type\":\"InterstateEdge\"}},\"dst\":\"1\",\"src\":\"0\",\"type\":\"Edge\"}],\"nodes\":[{\"attributes\":{\"_meta_dynamic_executions\":{\"category\":\"General\",\"default\":true,\"desc\":\"The number of executions of this state is dynamic\",\"metatype\":\"bool\"},\"_meta_executions\":{\"category\":\"General\",\"default\":0,\"desc\":\"The number of times this state gets executed (0 stands for unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"metatype\":\"bool\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_nosync\":{\"category\":\"General\",\"default\":false,\"desc\":\"Do not synchronize at the end of the state\",\"metatype\":\"bool\"},\"_meta_ranges\":{\"category\":\"General\",\"default\":{},\"desc\":\"Variable ranges, typically within loops\",\"metatype\":\"dict\"},\"dynamic_executions\":true,\"executions\":\"0\",\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"location\":{},\"nosync\":false,\"ranges\":{}},\"collapsed\":false,\"edges\":[{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":null,\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":null,\"subset\":null,\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"1\",\"dst_connector\":null,\"src\":\"0\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_c\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"M*N\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"M*N\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"3\",\"dst_connector\":null,\"src\":\"2\",\"src_connector\":\"OUT__c\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_c\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"_o0\",\"start\":\"_o0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"_o1\",\"start\":\"_o1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"_o0\",\"start\":\"_o0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"_o1\",\"start\":\"_o1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":\"IN__c\",\"src\":\"1\",\"src_connector\":\"out\",\"type\":\"MultiConnectorEdge\"}],\"id\":0,\"label\":\"_MatMult_gemm_initstate\",\"nodes\":[{\"attributes\":{\"_meta_collapse\":{\"category\":\"General\",\"default\":1,\"desc\":\"How many dimensions to collapse into the parallel range\",\"indirected\":true,\"metatype\":\"int\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"indirected\":true,\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"indirected\":true,\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"indirected\":true,\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Label of the map\",\"indirected\":true,\"metatype\":\"str\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_params\":{\"category\":\"General\",\"default\":[],\"desc\":\"Mapped parameters\",\"indirected\":true,\"metatype\":\"list\"},\"_meta_range\":{\"category\":\"General\",\"default\":{\"ranges\":[],\"type\":\"Range\"},\"desc\":\"Ranges of map parameters\",\"indirected\":true,\"metatype\":\"Range\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Map schedule\",\"indirected\":true,\"metatype\":\"ScheduleType\"},\"_meta_unroll\":{\"category\":\"General\",\"default\":false,\"desc\":\"Map unrolling\",\"indirected\":true,\"metatype\":\"bool\"},\"collapse\":1,\"debuginfo\":{\"end_column\":0,\"end_line\":119,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\",\"start_column\":0,\"start_line\":119,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"gemm_init_map\",\"out_connectors\":{},\"params\":[\"_o0\",\"_o1\"],\"range\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"schedule\":\"Default\",\"unroll\":false},\"id\":0,\"label\":\"gemm_init_map[_o0=0:M, _o1=0:N]\",\"scope_entry\":null,\"scope_exit\":\"2\",\"type\":\"MapEntry\"},{\"attributes\":{\"_meta_code\":{\"category\":\"General\",\"default\":{\"language\":\"Python\",\"string_data\":\"\"},\"desc\":\"Tasklet code\",\"metatype\":\"CodeBlock\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_environments\":{\"category\":\"General\",\"default\":[],\"desc\":\"Environments required by CMake to build and run this code node.\",\"metatype\":\"set\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Name of the CodeNode\",\"metatype\":\"str\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"code\":{\"language\":\"Python\",\"string_data\":\"out = 0\"},\"debuginfo\":{\"end_column\":0,\"end_line\":119,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\",\"start_column\":0,\"start_line\":119,\"type\":\"DebugInfo\"},\"environments\":[],\"in_connectors\":{},\"instrument\":\"No_Instrumentation\",\"label\":\"gemm_init\",\"location\":{},\"out_connectors\":{\"out\":null}},\"id\":1,\"label\":\"gemm_init\",\"scope_entry\":\"0\",\"scope_exit\":\"2\",\"type\":\"Tasklet\"},{\"attributes\":{\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"in_connectors\":{\"IN__c\":null},\"out_connectors\":{\"OUT__c\":null}},\"id\":2,\"label\":\"gemm_init_map[_o0=0:M, _o1=0:N]\",\"scope_entry\":\"0\",\"scope_exit\":\"2\",\"type\":\"MapExit\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"WriteOnly\",\"data\":\"_c\",\"debuginfo\":{\"end_column\":0,\"end_line\":1317,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\",\"start_column\":0,\"start_line\":1317,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":3,\"label\":\"_c\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"}],\"scope_dict\":{\"0\":[1,2],\"-1\":[0,3]},\"type\":\"SDFGState\"},{\"attributes\":{\"_meta_dynamic_executions\":{\"category\":\"General\",\"default\":true,\"desc\":\"The number of executions of this state is dynamic\",\"metatype\":\"bool\"},\"_meta_executions\":{\"category\":\"General\",\"default\":0,\"desc\":\"The number of times this state gets executed (0 stands for unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"metatype\":\"bool\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_nosync\":{\"category\":\"General\",\"default\":false,\"desc\":\"Do not synchronize at the end of the state\",\"metatype\":\"bool\"},\"_meta_ranges\":{\"category\":\"General\",\"default\":{},\"desc\":\"Variable ranges, typically within loops\",\"metatype\":\"dict\"},\"dynamic_executions\":true,\"executions\":\"0\",\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"location\":{},\"nosync\":false,\"ranges\":{}},\"collapsed\":false,\"edges\":[{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_a\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"K*M*N\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"K*M*N\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"6\",\"dst_connector\":\"IN__a\",\"src\":\"4\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_b\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"K*M*N\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"K*M*N\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"6\",\"dst_connector\":\"IN__b\",\"src\":\"3\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_a\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"16384\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i0 + 127\",\"main\":\"Min(M - 1, tile___i0 + 127)\"},\"start\":\"tile___i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i2 + 127\",\"main\":\"Min(K - 1, tile___i2 + 127)\"},\"start\":\"tile___i2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i0 + 127\",\"main\":\"Min(M - 1, tile___i0 + 127)\"},\"start\":\"tile___i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i2 + 127\",\"main\":\"Min(K - 1, tile___i2 + 127)\"},\"start\":\"tile___i2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"16384\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"0\",\"dst_connector\":\"IN__a\",\"src\":\"6\",\"src_connector\":\"OUT__a\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_a\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"__i0\",\"start\":\"__i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i2\",\"start\":\"__i2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"__i0\",\"start\":\"__i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i2\",\"start\":\"__i2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"1\",\"dst_connector\":\"__a\",\"src\":\"0\",\"src_connector\":\"OUT__a\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_b\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"16384\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i2 + 127\",\"main\":\"Min(K - 1, tile___i2 + 127)\"},\"start\":\"tile___i2\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i1 + 127\",\"main\":\"Min(N - 1, tile___i1 + 127)\"},\"start\":\"tile___i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i2 + 127\",\"main\":\"Min(K - 1, tile___i2 + 127)\"},\"start\":\"tile___i2\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i1 + 127\",\"main\":\"Min(N - 1, tile___i1 + 127)\"},\"start\":\"tile___i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"16384\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"0\",\"dst_connector\":\"IN__b\",\"src\":\"6\",\"src_connector\":\"OUT__b\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_b\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"__i2\",\"start\":\"__i2\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i1\",\"start\":\"__i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"__i2\",\"start\":\"__i2\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i1\",\"start\":\"__i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"1\",\"dst_connector\":\"__b\",\"src\":\"0\",\"src_connector\":\"OUT__b\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_c\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"K*M*N\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"K*M*N\",\"wcr\":\"(lambda x, y: (x + y))\",\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"5\",\"dst_connector\":null,\"src\":\"7\",\"src_connector\":\"OUT__c\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_c\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i0 + 127\",\"main\":\"Min(M - 1, tile___i0 + 127)\"},\"start\":\"tile___i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i1 + 127\",\"main\":\"Min(N - 1, tile___i1 + 127)\"},\"start\":\"tile___i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"16384\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i0 + 127\",\"main\":\"Min(M - 1, tile___i0 + 127)\"},\"start\":\"tile___i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i1 + 127\",\"main\":\"Min(N - 1, tile___i1 + 127)\"},\"start\":\"tile___i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"16384\",\"wcr\":\"(lambda x, y: (x + y))\",\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"7\",\"dst_connector\":\"IN__c\",\"src\":\"2\",\"src_connector\":\"OUT__c\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"_c\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"__i0\",\"start\":\"__i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i1\",\"start\":\"__i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"__i0\",\"start\":\"__i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":\"__i1\",\"start\":\"__i1\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":\"(lambda x, y: (x + y))\",\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":\"IN__c\",\"src\":\"1\",\"src_connector\":\"__out\",\"type\":\"MultiConnectorEdge\"}],\"id\":1,\"label\":\"_MatMult_gemm_state\",\"nodes\":[{\"attributes\":{\"_meta_collapse\":{\"category\":\"General\",\"default\":1,\"desc\":\"How many dimensions to collapse into the parallel range\",\"indirected\":true,\"metatype\":\"int\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"indirected\":true,\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"indirected\":true,\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"indirected\":true,\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Label of the map\",\"indirected\":true,\"metatype\":\"str\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_params\":{\"category\":\"General\",\"default\":[],\"desc\":\"Mapped parameters\",\"indirected\":true,\"metatype\":\"list\"},\"_meta_range\":{\"category\":\"General\",\"default\":{\"ranges\":[],\"type\":\"Range\"},\"desc\":\"Ranges of map parameters\",\"indirected\":true,\"metatype\":\"Range\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Map schedule\",\"indirected\":true,\"metatype\":\"ScheduleType\"},\"_meta_unroll\":{\"category\":\"General\",\"default\":false,\"desc\":\"Map unrolling\",\"indirected\":true,\"metatype\":\"bool\"},\"collapse\":1,\"debuginfo\":{\"end_column\":0,\"end_line\":161,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\",\"start_column\":0,\"start_line\":161,\"type\":\"DebugInfo\"},\"in_connectors\":{\"IN__a\":null,\"IN__b\":null},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"gemm_map\",\"out_connectors\":{\"OUT__a\":null,\"OUT__b\":null},\"params\":[\"__i0\",\"__i1\",\"__i2\"],\"range\":{\"ranges\":[{\"end\":{\"approx\":\"tile___i0 + 127\",\"main\":\"Min(M - 1, tile___i0 + 127)\"},\"start\":\"tile___i0\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i1 + 127\",\"main\":\"Min(N - 1, tile___i1 + 127)\"},\"start\":\"tile___i1\",\"step\":\"1\",\"tile\":\"1\"},{\"end\":{\"approx\":\"tile___i2 + 127\",\"main\":\"Min(K - 1, tile___i2 + 127)\"},\"start\":\"tile___i2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"schedule\":\"Default\",\"unroll\":false},\"id\":0,\"label\":\"gemm_map[__i0=tile___i0:Min(M - 1, tile___i0 + 127) + 1, __i1=tile___i1:Min(N - 1, tile___i1 + 127) + 1, __i2=tile___i2:Min(K - 1, tile___i2 + 127) + 1]\",\"scope_entry\":\"6\",\"scope_exit\":\"2\",\"type\":\"MapEntry\"},{\"attributes\":{\"_meta_code\":{\"category\":\"General\",\"default\":{\"language\":\"Python\",\"string_data\":\"\"},\"desc\":\"Tasklet code\",\"metatype\":\"CodeBlock\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_environments\":{\"category\":\"General\",\"default\":[],\"desc\":\"Environments required by CMake to build and run this code node.\",\"metatype\":\"set\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Name of the CodeNode\",\"metatype\":\"str\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"code\":{\"language\":\"Python\",\"string_data\":\"__out = (__a * __b)\"},\"debuginfo\":{\"end_column\":0,\"end_line\":161,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/libraries/blas/nodes/gemm.py\",\"start_column\":0,\"start_line\":161,\"type\":\"DebugInfo\"},\"environments\":[],\"in_connectors\":{\"__a\":null,\"__b\":null},\"instrument\":\"No_Instrumentation\",\"label\":\"gemm\",\"location\":{},\"out_connectors\":{\"__out\":null}},\"id\":1,\"label\":\"gemm\",\"scope_entry\":\"0\",\"scope_exit\":\"2\",\"type\":\"Tasklet\"},{\"attributes\":{\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"in_connectors\":{\"IN__c\":null},\"out_connectors\":{\"OUT__c\":null}},\"id\":2,\"label\":\"gemm_map[__i0=tile___i0:Min(M - 1, tile___i0 + 127) + 1, __i1=tile___i1:Min(N - 1, tile___i1 + 127) + 1, __i2=tile___i2:Min(K - 1, tile___i2 + 127) + 1]\",\"scope_entry\":\"0\",\"scope_exit\":\"2\",\"type\":\"MapExit\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadOnly\",\"data\":\"_b\",\"debuginfo\":{\"end_column\":0,\"end_line\":1312,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\",\"start_column\":0,\"start_line\":1312,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":3,\"label\":\"_b\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadOnly\",\"data\":\"_a\",\"debuginfo\":{\"end_column\":0,\"end_line\":1312,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\",\"start_column\":0,\"start_line\":1312,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":4,\"label\":\"_a\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"WriteOnly\",\"data\":\"_c\",\"debuginfo\":{\"end_column\":0,\"end_line\":1317,\"filename\":\"/home/sumun/.local/lib/python3.9/site-packages/dace/sdfg/state.py\",\"start_column\":0,\"start_line\":1317,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":5,\"label\":\"_c\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_collapse\":{\"category\":\"General\",\"default\":1,\"desc\":\"How many dimensions to collapse into the parallel range\",\"indirected\":true,\"metatype\":\"int\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"indirected\":true,\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"indirected\":true,\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"indirected\":true,\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Label of the map\",\"indirected\":true,\"metatype\":\"str\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_params\":{\"category\":\"General\",\"default\":[],\"desc\":\"Mapped parameters\",\"indirected\":true,\"metatype\":\"list\"},\"_meta_range\":{\"category\":\"General\",\"default\":{\"ranges\":[],\"type\":\"Range\"},\"desc\":\"Ranges of map parameters\",\"indirected\":true,\"metatype\":\"Range\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Map schedule\",\"indirected\":true,\"metatype\":\"ScheduleType\"},\"_meta_unroll\":{\"category\":\"General\",\"default\":false,\"desc\":\"Map unrolling\",\"indirected\":true,\"metatype\":\"bool\"},\"collapse\":1,\"debuginfo\":null,\"in_connectors\":{\"IN__a\":null,\"IN__b\":null},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"gemm_map\",\"out_connectors\":{\"OUT__a\":null,\"OUT__b\":null},\"params\":[\"tile___i0\",\"tile___i1\",\"tile___i2\"],\"range\":{\"ranges\":[{\"end\":\"M - 1\",\"start\":\"0\",\"step\":\"128\",\"tile\":\"1\"},{\"end\":\"N - 1\",\"start\":\"0\",\"step\":\"128\",\"tile\":\"1\"},{\"end\":\"K - 1\",\"start\":\"0\",\"step\":\"128\",\"tile\":\"1\"}],\"type\":\"Range\"},\"schedule\":\"Default\",\"unroll\":false},\"id\":6,\"label\":\"gemm_map[tile___i0=0:M:128, tile___i1=0:N:128, tile___i2=0:K:128]\",\"scope_entry\":null,\"scope_exit\":\"7\",\"type\":\"MapEntry\"},{\"attributes\":{\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"in_connectors\":{\"IN__c\":null},\"out_connectors\":{\"OUT__c\":null}},\"id\":7,\"label\":\"gemm_map[tile___i0=0:M:128, tile___i1=0:N:128, tile___i2=0:K:128]\",\"scope_entry\":\"6\",\"scope_exit\":\"7\",\"type\":\"MapExit\"}],\"scope_dict\":{\"0\":[1,2],\"6\":[0,7],\"-1\":[3,4,5,6]},\"type\":\"SDFGState\"}],\"sdfg_list_id\":1,\"type\":\"SDFG\"}","symbol_mapping":{"K":"K","M":"M","N":"N"}},"id":3,"label":"_MatMult_gemm","scope_entry":null,"scope_exit":null,"type":"NestedSDFG"}],"scope_dict":{"-1":[0,1,2,3]},"type":"SDFGState"}],"sdfg_list_id":0,"type":"SDFG"}